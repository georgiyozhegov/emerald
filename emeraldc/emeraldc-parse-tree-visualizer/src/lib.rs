// WARNING: This code is generated by DeepSeek

use emeraldc_parser::{
    Declaration, Expression, FatalParserError, ParsedNode, Parser, Statement,
};
use std::fs::File;
use std::io::Write;

pub struct Visualizer;

impl Visualizer {
    pub fn visualize(
        source: &str,
        parse_tree: impl Iterator<
            Item = Result<ParsedNode<Declaration>, FatalParserError>,
        >,
    ) -> String {
        let mut html = String::new();
        let parse_tree: Vec<Result<ParsedNode<Declaration>, FatalParserError>> = parse_tree.collect();
        generate_html(&source, &parse_tree, &mut html);
        html
    }
}

fn generate_html(
    source: &str,
    nodes: &[Result<
        ParsedNode<Declaration>,
        emeraldc_parser::FatalParserError,
    >],
    output: &mut String,
) {
    output.push_str(
        r#"<!DOCTYPE html>
<html>
<head>
    <title>EmeraldC Parse Tree Visualizer</title>
    <style>
        body { font-family: monospace; }
        #code { position: relative; white-space: pre; }
        .token { position: relative; }
        .token:hover { background-color: #ffffcc; }
        .popup {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            min-width: 200px;
        }
    </style>
</head>
<body>
    <h1>EmeraldC Source with Parse Tree Info</h1>
    <div id="code">"#,
    );

    let mut last_pos = 0;
    for node in nodes {
        if let Ok(parsed_node) = node {
            generate_node_html(source, parsed_node, output, &mut last_pos);
        }
    }
    // Add any remaining source text
    if last_pos < source.len() {
        push_escaped(&source[last_pos..], output);
    }

    output.push_str(
        r#"</div>
    <div id="popup" class="popup" style="display: none;"></div>
    <script>
        const popup = document.getElementById('popup');
        document.querySelectorAll('.token').forEach(el => {
            el.addEventListener('mouseover', e => {
                const rect = e.target.getBoundingClientRect();
                popup.style.display = 'block';
                popup.style.left = `${rect.left}px`;
                popup.style.top = `${rect.bottom + window.scrollY}px`;
                popup.innerHTML = e.target.dataset.info;
            });
            el.addEventListener('mouseout', () => {
                popup.style.display = 'none';
            });
        });
    </script>
</body>
</html>"#,
    );
}

fn generate_node_html(
    source: &str,
    node: &ParsedNode<Declaration>,
    output: &mut String,
    last_pos: &mut usize,
) {
    match &node.node {
        Ok(Declaration::Function {
            _introducer,
            identifier,
            _open_round,
            _close_round,
            body,
            _end,
        }) => {
            // Add text before declaration
            if _introducer.span.start > *last_pos {
                push_escaped(
                    &source[*last_pos.._introducer.span.start],
                    output,
                );
                *last_pos = _introducer.span.start;
            }

            // Process function parts
            generate_token_html(
                source,
                _introducer,
                "Keyword",
                output,
                last_pos,
            );
            generate_token_html(
                source,
                identifier,
                "Identifier",
                output,
                last_pos,
            );
            generate_token_html(
                source,
                _open_round,
                "Punctuation",
                output,
                last_pos,
            );
            generate_token_html(
                source,
                _close_round,
                "Punctuation",
                output,
                last_pos,
            );

            // Process function body
            for stmt in body {
                if let Ok(Statement::Let {
                    _introducer,
                    identifier,
                    _equal,
                    value,
                }) = &stmt.node
                {
                    generate_token_html(
                        source,
                        _introducer,
                        "Keyword",
                        output,
                        last_pos,
                    );
                    generate_token_html(
                        source,
                        identifier,
                        "Identifier",
                        output,
                        last_pos,
                    );
                    generate_token_html(
                        source, _equal, "Operator", output, last_pos,
                    );
                    generate_expression_html(source, value, output, last_pos);
                }
            }

            generate_token_html(source, _end, "Keyword", output, last_pos);
        }
        Err(e) => {
            let error_text =
                format!("<span style='color:red'>ERROR: {:?}</span>", e);
            push_escaped(&source[node.span.start..node.span.end], output);
            output.push_str(&error_text);
            *last_pos = node.span.end;
        }
    }
}

fn generate_expression_html(
    source: &str,
    expr: &ParsedNode<Expression>,
    output: &mut String,
    last_pos: &mut usize,
) {
    match &expr.node {
        Ok(Expression::Integer) => {
            push_escaped(&source[expr.span.start..expr.span.end], output);
            *last_pos = expr.span.end;
        }
        Ok(Expression::Variable(_)) => {
            push_escaped(&source[expr.span.start..expr.span.end], output);
            *last_pos = expr.span.end;
        }
        Ok(Expression::Binary {
            left,
            operator,
            right,
        }) => {
            generate_expression_html(source, left, output, last_pos);
            generate_token_html(source, operator, "Operator", output, last_pos);
            generate_expression_html(source, right, output, last_pos);
        }
        Ok(Expression::Parenthesized {
            _open_round,
            inner,
            _close_round,
        }) => {
            generate_token_html(
                source,
                _open_round,
                "Punctuation",
                output,
                last_pos,
            );
            generate_expression_html(source, inner, output, last_pos);
            generate_token_html(
                source,
                _close_round,
                "Punctuation",
                output,
                last_pos,
            );
        }
        Err(e) => {
            let error_text =
                format!("<span style='color:red'>ERROR: {:?}</span>", e);
            push_escaped(&source[expr.span.start..expr.span.end], output);
            output.push_str(&error_text);
            *last_pos = expr.span.end;
        }
    }
}

fn generate_token_html(
    source: &str,
    token: &ParsedNode<impl std::fmt::Debug>,
    token_type: &str,
    output: &mut String,
    last_pos: &mut usize,
) {
    let text = &source[token.span.start..token.span.end];
    let info = format!(
        "Type: {}<br>Span: ({}, {})<br>Node: {:?}<br>Error: {}",
        token_type,
        token.span.start,
        token.span.end,
        token.node,
        if token.node.is_err() { "Yes" } else { "No" }
    );

    output.push_str(&format!(
        r#"<span class="token" data-info="{}">"#,
        escape_html(&info)
    ));
    push_escaped(text, output);
    output.push_str("</span>");

    *last_pos = token.span.end;
}

fn push_escaped(text: &str, output: &mut String) {
    output.extend(
        text.chars()
            .flat_map(|c| match c {
                '<' => Some("&lt;"),
                '>' => Some("&gt;"),
                '&' => Some("&amp;"),
                '"' => Some("&quot;"),
                '\'' => Some("&#39;"),
                _ => None,
            })
            .map(|s| s.to_string()),
    );
}

fn escape_html(s: &str) -> String {
    s.chars()
        .flat_map(|c| match c {
            '"' => Some("&quot;".to_string()),
            _ => None,
        })
        .map(|s| s.to_string())
        .collect()
}
